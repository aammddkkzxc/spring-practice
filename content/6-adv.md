## 쓰레드 로컬, 템플릿 콜백 패턴 (adv-1)

### http 요청 구분 (동기화) - parameter 전달 방식 (V2)
- V2 방식은 파라미터로 TraceId를 전파해야 하므로, 코드 변경 범위가 큼 (모든 메서드 시그니처 & 호출부 수정 필요)
- 최초 호출(begin)과 중첩 호출(beginSync)을 구분하는 로직이 필요
- Controller를 거치지 않는 서비스 호출의 경우 TraceId를 생성/전달할 타이밍 제약 발생

### http 요청 구분 (동기화) - ThreadLocal (V3)
- 파라미터 방식을 쓰지 않기 위해 필드로 TraceId를 가지는 방식을 선택할 수 있다(FieldLogTrace)
  - 스프링의 기본 스코프인 싱글톤 빈은 여러 요청/쓰레드가 동시에 같은 인스턴스를 공유
  - TraceId 필드 동시성 문제 발생
- ThreadLocal은 “현재 쓰레드에만 국한된 값 저장소”를 제공한
  - 동일한 ThreadLocal 인스턴스라도 쓰레드마다 별도의 슬롯을 가지므로 서로 값을 침범하지 않는다
- ThreadLocal 사용 시 주의사항
  - 비동기 흐름일 시 값이 자동 전파되지 않는다. (참고 : 데코레이터 패턴 사용해서 해결)
  - 쓰레드 풀 환경
    - 쓰레드 풀에서는 쓰레드가 재사용된다.
    - 요청 A가 끝난 후에도 해당 쓰레드의 ThreadLocalMap에 값이 남아 있으면, 다음 요청 B가 같은 쓰레드를 배정받을 때 A의 값이 유출될 수 있다
    - 반드시 작업이 끝난 시점에 remove()로 정리해야 한다

### http 요청 구분 (동기화) - TemplateMethod (V4)
- 템플릿 메서드 패턴
  - 목표 : 상위 클래스에 알고리즘의 “골격(템플릿)”을 정의하고, 일부 단계는 하위 클래스에서 재정의하여 알고리즘의 구조는 유지하되 세부만 바꾼다
- 추상 클래스(템플릿) : 변하지 않는 공통 흐름을 구현하고, 변하는 지점은 추상 메서드로 위임한다. 
- 하위 클래스 : 추상 메서드를 오버라이드하여 구체 로직을 채운다. 
- 특징 
  - 다형성(상속+오버라이딩)으로 변하는 부분을 교체. 
  - 중복 제거: 공통 부가 기능(시간 측정, 로깅 등)을 한 곳에 집중.)
- 단점
  - 상속에 따른 강결합
  - 유연성 저하 : 상속은 정적 구조, 조합/주입에 비해 대체·확장이 덜 유연. 
  - 클래스/익명 내부 클래스 증가로 복잡도 상승 가능.

### 전략 패턴 - strategy
- 전략 패턴
  - 목표 : 알고리즘군을 정의하고 캡슐화하여 상호 교환 가능하게 하며, 클라이언트와 독립적으로 알고리즘 변경
- 구조 
  - Strategy(인터페이스) : 변하는 알고리즘의 계약
  - Strategy 구현체 : 구체 알고리즘 구현
  - Context : 변하지 않는 흐름(템플릿 역할) 보유, 전략에 위임하여 변하는 단계 실행
- 주입 방식 두 가지 
  - 필드 주입형(ContextV1): Context가 Strategy를 필드로 보관하고 선 조립, 후 실행 
  - 파라미터 전달형(ContextV2): execute 호출 시마다 Strategy를 인수로 받아 유연하게 교체
    - 템플릿 콜백 패턴 이라 한다

### 템플릿 콜백 패턴 - callback
- 전략 패턴에서 Context 가 템플릿 역할, Strategy 부분이 콜백
- 스프링에서의 활용 
  - JdbcTemplate, RestTemplate, TransactionTemplate, RedisTemplate 등 “XxxTemplate” 명명 규칙. 
  - 템플릿이 부가 기능(자원 관리, 예외 변환, 트랜잭션 경계 등)을 담당하고, 콜백이 핵심 로직만 제공.
- 여전한 문제
  - 콜백 인터페이스·람다 시그니처 관리 필요

## 프록시, 동적 프록시, 스프링과 프록시, 빈 후처리기 (adv-2)
- 클라이언트와 실제 대상 객체 사이에 위치해 호출을 대신 처리하는 대리자 객체로, 중간에서 접근 제어 또는 부가 기능을 수행
- 프록시를 실제 스프링 빈 대신 등록한다. 실제 객체는 스프링 빈으로 등록하지 않는다

#### 프록시 패턴 vs 데코레이터 패턴
- 의도(intent)
  - 디자인 패턴에서 중요한 것은 해당 패턴의 겉모양이 아니라 그 패턴을 만든 의도가 더 중요
  - 따라서 의도에 따라 패턴을 구분
- 프록시 패턴 : 다른 개체에 대한 접근을 제어하기 위해 대리자를 제공
- 데코레이터 패턴 : 객체에 추가 책임(기능)을 동적으로 추가하고, 기능 확장을 위한 유연한 대안 제공

#### 인터페이스 기반 프록시 vs 클래스 기반 프록시
- 클래스 기반 프록시는 해당 클래스에만 적용
- 인터페이스 기반 프록시는 인터페이스만 같으면 모든 곳 에 적용
- 클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 있다
  - 부모 클래스의 생성자를 호출해야 한다 ( super(null); )
  - 클래스, 메소드에 final 키워드가 있다면 불가

### 동적 프록시 기술

#### JDK 동적 프록시
- 인터페이스 기반 프록시를 런타임에 생성
- 대상마다 별도 프록시 클래스를 만들 필요 없이, 공통 InvocationHandler에 로직을 모아 재사용
- 인터페이스가 있어야만 적용 가능

#### CGLIB
- 바이트코드 조작으로 동적 클래스를 생성하는 라이브러리. 
- 인터페이스가 없어도(구체 클래스만 있어도) 프록시 생성 가능.
- 스프링 : 내부에 CGLIB 포함. 실제로는 ProxyFactory 등 스프링 추상화를 통해 쉽게 사용
- CGLIB는 인터페이스 기반 + 클래스 기반을 모두 지원
- 클래스 기반 프록시 -> 상속을 사용하기 때문에 몇가지 제약
  - 부모 클래스의 생성자를 체크
  - 클래스 메서드 final 불가

#### 한계
- 인터페이스가 있으면 JDK 동적 프록시, 없으면 CGLIB로 적용 가능.
- 두 기술을 함께 사용할 때 동일 부가기능을 위해 각각 InvocationHandler와 MethodInterceptor를 중복 구현·관리해야 하는가
- 메서드 이름 필터 같은 조건부 적용을 공통적으로 제공할 수 있는가?

### 스프링이 지원하는 프록시
- 스프링은 JDK 동적 프록시(인터페이스 기반)와 CGLIB(구체 클래스 상속 기반)를 일관되게 사용할 수 있도록 ProxyFactory를 제공
- 대상에 인터페이스가 있으면 기본적으로 JDK 동적 프록시를, 없으면 CGLIB을 사용하며, 옵션으로 강제 전환도 가능
  - proxyTargetClass=true, 스프링 부트 AOP는 기본적으로 이 설정 사용하여 CGLIB사용
- 추상화 개념인 Advice 도입
  - 개발자는 Advice 구현하여 프록시 팩토리를 통해서 만든 프록시가 사용할 부가기능 로직을 설정
  - MethodInterceptor 는 Interceptor 를 상속,Interceptor 는 Advice 인터페이스를 상속
  - MethodInterceptor 구현해서 사용, CGLIB의 MethodInterceptor와 구분
  - 프록시 팩토리가 내부에서 JDK 동적 프록시인 경우 -> InvocationHandler가 Advice 호출, CGLIB인 경우 -> MethodInterceptor가 Advice 호출

#### 포인트컷, 어드바이스, 어드바이저
- 포인트컷( Pointcut ): 어디에 부가 기능을 적용할지, 어디에 부가 기능을 적용하지 않을지 판단하는 필터링 로직
- 어드바이스( Advice ): 이전에 본 것 처럼 프록시가 호출하는 부가 기능
- 어드바이저( Advisor ): 포인트컷1 + 어드바이스1
- 포인트컷
  - 스프링은 무수히 많은 포인트컷을 제공
  - 실무에서는 aspectJ 표현식을 기반으로 사용하는 AspectJExpressionPointcut사용 (가장 편리)
- 여러 어드바이저
  - 여러 부가 기능을 적용하기 위해 프록시를 중첩 생성할 수 있으나, 이는 프록시 수가 불필요하게 많아짐
  - 스프링은 “하나의 프록시”에 “여러 Advisor”를 등록해 순차 적용하도록 최적화

#### 한계
- 문제1 : 설정량 과다. 스프링 빈이 많아질수록 각 빈마다 ProxyFactory 설정 및 프록시 생성을 반복해야 하는 “설정 지옥”.
- 문제2 : 컴포넌트 스캔 환경(V3)에서는 이미 실제 객체가 빈으로 등록 되어 버린 상태 (프록시 객체를 등록해야함)

### 빈 후처리기
- 빈 저장소에 등록할 목적으로 생성한 객체를 빈 저장소에 등록하기 직전 작업
  - 객체 조작, 다른 객체로 바꿔치기
- 빈 생성 -> 빈 후처리기에 전달 -> 처리 작업 -> 빈 등록
- BeanPostProcessor 인터페이스
  - postProcessBeforeInitialization : 객체 생성 후 @PostConstruct 같은 초기화가 발생하기 전 호출
  - postProcessAfterInitialization : 객체 생성 후 @PostConstruct 같은 초기화가 발생한 다음 호출
- 빈 후처리기를 사용하면 (PackageLogTraceProxyPostProcessor, BeanPostProcessorConfig)
  - 프록시를 생성하는 코드가 설정 파일에는 필요X
  - 순수한 빈 등록만 고민
  - 프록시를 생성하고 프록시를 스프링 빈으로 등록하는 것은 빈 후처리기가 모두 처리

#### 스프링이 제공하는 빈 후처리기
- 자동 프록시 생성기 도입(AOP 스타터 의존성)
  - build.gradle: spring-boot-starter-aop 추가 시 aspectjweaver 포함, 스프링 부트가 AOP 관련 빈을 자동 구성 
  - AnnotationAwareAspectJAutoProxyCreator 자동 등록 
    - 스프링 컨테이너에 등록된 모든 Advisor를 수집 
    - 포인트컷으로 프록시 “적용 대상 빈”을 선별(클래스/메서드 전체 검사, 하나라도 매칭되면 프록시 생성)
    - 프록시 생성 후 빈으로 등록(대상이 아니면 원본 등록)
    - 프록시 내부는 target과 advisors를 보유
  - 개발자는 “Advisor 빈만” 등록하면 된다. BeanPostProcessor를 직접 만들 필요 없음
  - AnnotationAwareAspectJAutoProxyCreator 는 @AspectJ와 관련된 AOP 기능도 자동으로 찾아서 처리.
    - Advisor 는 물론이고, @Aspect 도 자동으로 인식해서 프록시를 만들고 AOP를 적용
- 중요: 포인트컷은 두 군데 쓰인다
  - 프록시 “생성 여부” 결정(생성 단계)
  - 호출 시 어드바이스 “적용 여부” 결정(사용 단계)
- AspectJExpressionPointcut
  - AspectJ라는 AOP에 특화된 포인트컷 표현식
  - 광범위 매칭으로 내부 빈에까지 적용되지 않도록 AspectJ 표현식으로 범위/예외를 정밀하게 설정 가능
- 여러 Advisor 적용
  - 하나의 스프링 빈이 여러 포인트컷에 매칭되면 프록시는 하나만 생성되고, 해당 프록시에 여러 Advisor가 포함
  - 모든 포인트컷 불만족시 -> 프록시 생성X

### @Aspect AOP
- 스프링은 @Aspect 애노테이션으로 매우 편리하게 포인트컷과 어드바이스로 구성되어 있는 어드바이저 생성 기능 지원
- @Aspect : 애노테이션 기반 프록시를 적용
- @Around("execution(* hello.proxy.app..*(..))")
  - @Around 의 값에 포인트컷 표현식을 넣는다. 표현식은 AspectJ 표현식을 사용
  - @Around 의 메서드는 어드바이스( Advice )
- ProceedingJoinPoint joinPoint 
  - 어드바이스에서 살펴본 MethodInvocation invocation 과 유사한 기능
  - 내부에 실제 호출 대상, 전달 인자, 그리고 어떤 객체와 어떤 메서드가 호출되었는지 정보가 포함

## 스프링 AOP (adv-3)
- 애플리케이션의 공통된 부가 기능(횡단 관심사)를 모듈화하여 관리. 로그 추적, 트랜잭션 처리 등
- AOP는 이러한 문제를 해결하기 위해 부가 기능과 그 기능을 어디에 적용할지 선택하는 로직을 하나로 묶어 모듈화하는데, 이를 애스펙트(Aspect)라고 한다
- AOP는 OOP를 대체하는 것이 아니라, 횡단 관심사 처리가 어려운 OOP를 보완하는 역할

#### AOP 적용 방식 참고
- 컴파일 시점 : 실제 대상 코드에 애스팩트를 통한 부가 기능 호출 코드가 포함.
  - AspectJ를 직접 사용 (특별한 컴파일러가 필요하고 과정이 복잡)
- 클래스 로딩 시점 : 실제 대상 코드에 애스팩트를 통한 부가 기능 호출 코드가 포함.
  - AspectJ를 직접 사용 (클래스 로더 조작기를 지정해야 하는데, 이 부분이 번거롭고 운영)
- 런타임 시점: 실제 대상 코드는 그대로 유지. 대신에 프록시를 통해 부가 기능이 적용
  - 프록시 방식의 AOP

#### AOP 적용 위치
- AOP 적용 가능 지점(조인 포인트): 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행
- 컴파일 시점과 클래스 로딩 시점에 적용하는 AOP는 바이트코드를 실제 조작, 해당 기능을 모든 지점에 다 적용
- 스프링 AOP는 메서드 실행 지점에만 AOP를 적용할 수 있다
  - 프록시는 메서드 오버라이딩 개념으로 동작
  - 따라서 생성자나 static 메서드, 필드 값 접근에는 프록시 개념이 적용될 수 없다. 
  - 프록시를 사용하는 스프링 AOP의 조인 포인트는 메서드 실행으로 제한

### AOP 구현
- AspectV1 : @Aspect 애너테이션으로 AOP 클래스를 정의하고, @Around를 사용해 대상 메서드의 실행 전후에 로그를 남기는 어드바이스를 작성
- AspectV2 : @Pointcut 애너테이션을 사용해 포인트컷을 별도의 메서드로 정의합니다. 이렇게 정의된 포인트컷 시그니처(allOrder())를 @Around에서 참조
- AspectV3 : 트랜잭션 처리를 위한 어드바이스(doTransaction)를 추가하고, &&(AND), ||(OR), !(NOT) 연산자로 포인트컷을 조합
- Pointcuts, AspectV4Pointcut : 공용 포인트컷을 별도의 클래스로 분리하여 관리, 사용
- AspectV5Order : 하나의 @Aspect 내에 있는 여러 어드바이스는 순서를 보장할 수 없다. 순서를 지정하려면 Aspect를 별도의 클래스로 분리한 후, 클래스 단위로 @Order 애너테이션을 적용
- AspectV6Advice : @Around 외에도 다양한 종류의 어드바이스
  - @Before, @AfterReturning, @AfterThrowing, @After
  - @Around만으로 모든 기능을 구현할 수 있긴 하다
    - 좋은 제약을 통한 실수 방지 (실수로 joinPoint.proceed()를 호출하지 않는 등)
    - 코드로 의도 명확히 드러내기

#### 포인트컷 지시자
- 매우 다양한 포인트컷 지시자가 있다
  - execution: 가장 많이 사용되는 지시자
  - @annotation: 메서드에 특정 애노테이션이 부여되어 있을 때 매칭
  - 두개 정도가 가장 많이 쓰인다. 사용 시 정확한 사용법과 차이점을 숙지후 적용
  - this 와 target
    - this : 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트
    - target : Target 객체(스프링 AOP 프록시가 가리키는 실제 대상)를 대상으로 하는 조인 포인트
    - 이 차이로 인해 프록시 생성 방식에 따라 주의점이 있다
      - JDK 동적 프록시로 만들어진 proxy 객체는 인터페이스를 기반으로 구현된 새로운 클래스
      - 기존 구현체를 전혀 알지 못하므로 AOP 적용 대상이 아니게 됨

### 프록시와 내부 호출 문제
- AOP를 적용하면 대상 객체(Target) 대신 AOP 기능이 추가된 프록시 객체를 스프링 빈으로 등록
- 따라서 모든 호출은 이 프록시를 통해 이루어져야 AOP가 정상적으로 동작
- 하지만 객체 내부의 메서드가 다른 메서드를 호출하는 경우(this.internal()), 프록시를 거치지 않고 대상 객체의 메서드를 직접 호출
- AOP 어드바이스 적용 안되는 문제 발생

#### 해결 방안

- 자기 자신 주입 (Self-Injection)
  - 수정자(Setter) 주입을 통해 자신의 프록시 객체를 주입받은 뒤, 내부 메서드를 프록시 객체를 통해 호출하는 방식 
  - 주의 : 생성자 주입을 사용하면 순환 참조(Circular Reference)가 발생하여 애플리케이션이 실행되지 않는다. 
- 지연 조회 (Lazy Lookup)
  - ObjectProvider나 ApplicationContext를 사용하여 빈(Bean)을 주입받고, 실제 메서드가 호출되는 시점에 프록시 객체를 조회해서 사용
  - 객체 생성 시점이 아닌 실제 사용 시점에 빈을 조회 
- 구조 변경 (가장 권장되는 방법)
  - 내부 호출이 필요한 로직을 별도의 클래스로 분리, 주입 받아 사용

### 프록시 기술의 한계와 스프링의 해결책
- 타입 캐스팅과 의존관계 주입 문제
  - JDK 동적 프록시는 인터페이스를 기반으로 프록시를 생성하므로, 실제 구현 클래스(MemberServiceImpl) 타입으로 의존관계를 주입받으려 하면 ClassCastException이 발생
  - 반면 CGLIB는 구현 클래스를 상속받아 프록시를 만들기 때문에, 구현 클래스 타입으로 주입받아도 문제가 없다
- CGLIB의 단점과 스프링의 해결
  - 과거 CGLIB는 '대상 클래스에 기본 생성자 필수', '생성자 2번 호출', 'final 키워드 클래스, 메서드 사용 불가'과 같은 단점이 있었다
  - 하지만 스프링은 objenesis 라이브러리를 도입하여 이러한 문제들을 해결
  - 이제 남은 한계는 final 키워드가 붙은 클래스나 메서드는 프록시를 생성할 수 없다는 점뿐이지만, 이는 일반적인 웹 애플리케이션 개발에서 크게 문제 되지 않음
- 스프링 부트의 선택 : CGLIB 기본 사용
  - 프로퍼티 파일에서 설정 가능하긴 함