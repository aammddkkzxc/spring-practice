### JDBC 등장 이유
- DB마다 커넥션 연결과 SQL 전달, 응답 방법이 달라, DB가 바뀌면 코드도 다 바꿔야 함
- JDBC 표준 인터페이스(java.sql.패키지) 제공 
  - Connection: 연결 
  - Statement: SQL 전달 
  - ResultSet: SQL 결과 
- DB 업체가 각자 구현 → “JDBC 드라이버" 제공
- 한계
  - SQL 문법, 데이터 타입이 DB마다 다름 (SQL은 표준이 있지만 100% 공통 X)

#### JDBC와 최신 데이터 접근 기술
- JDBC 직접 사용: 저수준, 직접 반복코드 많고 번거로움 
- SQL Mapper (Ex: JdbcTemplate, MyBatis)
  - 장점: 반복코드 줄임, 객체 변환 등 편리 
  - 단점: SQL 직접 작성해야 함 
- ORM (Ex: JPA, Hibernate)
  - 장점: SQL 작성 최소화, DB별 SQL 차이 자동 보정, 생산성↑ 
  - 단점: 배우기 쉽지 않음, 내부 원리 이해 필요
- SQL Mapper, ORM 내부에서도 결국 JDBC를 사용

#### JDBC 연결과 리소스 정리
- 연결
  - 애플리케이션 로직에서 커넥션이 필요하면 DriverManager.getConnection() 을 호출
  - DriverManager -> 라이브러리에 드라이버 목록 인식 (url, 이름, 비밀번호 등 추가정보 바탕으로)
  - 커넥션 반환
- 리소스 정리
  - TCP/IP 커넥션에 걸려 외부 리소스를 쓰는 것이라 꼭 종료해줘야 한다
  - 연결 역순으로 (ResultSet -> PreparedStatement -> Connection)

#### ResultSet
- ResultSet 내부에 있는 커서( cursor )를 이동해서 다음 데이터를 조회할 수 있다. 
- rs.next() : 이것을 호출하면 커서가 다음으로 이동한다.
- 최초의 커서는 데이터를 가리키고 있지 않기 때문에 rs.next() 를 최초 한번은 호출해야 데이터를 조회  
  - rs.next() 의 결과가 true 면 커서의 이동 결과 데이터가 있다는 뜻

### 커넥션 풀과 데이터소스 필요성

#### 데이터베이스 커넥션 획득의 문제점
- 과정 복잡, 매번 새로 획득하려면 시간 많이 소요됨
  - 애플리케이션이 DB 드라이버를 통해 커넥션 조회 
  - DB 드라이버가 DB 서버와 TCP/IP 네트워크 커넥션 연결 (3-way handshake 등)
  - DB 드라이버가 인증정보(아이디, 비밀번호 등) 전달 
  - DB가 인증을 마치고 내부 세션 생성 
  - 커넥션 생성 응답 반환 
  - 애플리케이션에서 커넥션 객체 사용

#### 커넥션 풀
- 애플리케이션 시작 시점에 커넥션을 미리 여러 개 만들어 풀에 보관. (ex: 10개)
  - 풀 사이즈 -> 성능 테스트를 통해 정한다
  - 최대 커넥션 수를 재한하여 db 보호하는 효과도 있음
- 애플리케이션 로직이 커넥션이 필요하면 DB 드라이버가 아닌 커넥션 풀에서 가져옴 (객체 참조로). 
- 쿼리/작업 후 커넥션을 풀에 "반환"(존재하는 커넥션을 살아있는 상태로 반환, 종료X). 
- 다음 요청은 다시 이 커넥션을 재사용
- HikariCP 보통 사용
- 커넥션 풀에 커넥션 채우는 것을 별도의 스레드를 사용 -> 애플리케이션 실행 시간에 영향을 주지 않도록

#### 데이터 소스
- 커넥션을 획득하는 방법 추상화 (DriverManager로 직접 받아오든, 특정 커넥션 풀 사용하든)
- 필요한 속성(url, 이름, 비밀번호)사용해서 생성, 인터페이스의 핵심 메소드는 커넥션 조회 하나
- 설정과 사용의 분리 역할

### 트랜잭션
- 트랜잭션 4원칙, 격리수준 4단계
- 클라이언트가 DB 서버 접속 시 커넥션 생성 → 내부적으로 세션 할당 
- 앞으로 해당 커넥션을 통한 모든 SQL 명령은 이 세션을 통해서 실행 
- 세션 -> 트랜잭션 시작/커밋/롤백 관리
- 커넥션 풀에서 10개 커넥션 생성 시 세션도 10개 생성됨
- 자동 커밋 / 수동 커밋
  - 보통 자동 커밋 모드가 기본으로 설정된 경우가 많기 때문에, 수동 커밋 모드로 설정하는 것을 트랜잭션을 시작한다고 표현할 수 있다.
  - 수동 커밋 설정을 하면 이후에 꼭 commit , rollback 을 호출해야 한다.
  - 한번 설정하면 해당 세션에서 계속 유지된다. 중간에 변경하는 것 가능 

#### 락
- DB 락으로 동시성 문제 해결, 타임 아웃 설정 가능
- 조회와 락
  - 일반적인 조회는 락을 사용하지 않는다
  - SELECT FOR UPDATE: 조회 시점에도 락 획득
  - 조회 해온 후 중요 금전적인 계산이 이루어 질 시 사용 가능

#### 커넥션과 세션
- 트랜잭션 -> 비지니스 로직이 있는 서비스 계층에서 시작해야 한다.
- 사용 하는 동안 같은 커넥션을 유지 해야 한다
- 애플리케이션에서 같은 커넥션을 유지 하는 가장 단순한 방법은 커넥션을 파라미터로 전달해서 사용하는 것 (V2)


### 스프링과 문제 해결

#### 문제
1. JDBC, JPA 등 데이터 접근 기술마다 트랜잭션 처리 코드가 다름
2. 트랜잭션 동기화 문제 : 커넥션 파라미터 전달 필요, 관리 어려움 / 1,2번 문제 합쳐 해결 -> RepoV3, ServiceV3_1
3. 트랜잭션 적용 반복문제 : try , catch , finally 를 포함한 트랜잭션 시작, 커밋, 롤백 코드 반복 / ServiceV3_2
4. 서비스 계층에 순수 비지니스 로직만 남겨야 한다 / ServiceV3_3
5. 데이터소스와 트랜잭션 매니저 의존성 관리 : 과거엔 빈 직접 등록 / ServiceV3_3_2Test
6. 예외 누수 문제 : JDBC 전용 체크 예외(SQLException)가 서비스 계층으로 전파 / RepoV4_1

#### 해결 (문제 순서와 맞춰 해결 한 방법 나열)
1. 트랜잭션 매니저 (추상화) 
   - 서비스가 추상화된 인터페이스에 의존(PlatformTransactionManager)
2. 트랜잭션 동기화 매니저
   - 쓰레드 로컬 ThreadLocal 사용 (쓰레드마다 별도의 저장소 부여)
   - DataSourceUtils로 커넥션 관리 -> 트랜잭션 내 동기화 유지된다
   - 과정
     - 트랜잭션 매니저는 데이터소스를 통해 커넥션 생성or사용, 트랜잭션을 시작 (서비스 계층의 transactionManager.getTransaction())
     - 커넥션을 수동 커밋 모드로 변경해서 실제 데이터베이스 트랜잭션을 시작
     - 트랜잭션 매니저는 커넥션을 트랜잭션 동기화 매니저에 보관
     - 리포지토리는 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용 (파라미터 불필요, DataSourceUtils 사용)
     - 커밋, 롤백 후 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을 종료, 커넥션 종료or반환, 리소스 정리
3. 트랜잭션 템플릿 콜백 패턴 사용 (TransactionTemplate)
   - 비즈니스 로직이 정상 수행되면 커밋
   - 체크 예외가 발생하면 롤백. 그 외의 경우 커밋
4. 트랜잭션 AOP, 스프링부트의 데이터소스 자동 등록
   - 스프링이 제공하는 AOP/프록시 사용 @Transactional, 스프링 컨테이너 필요
   - 서비스 계층에 순수한 비즈니스 로직만 남김
5. 스프링 부트 -> DI
   - application.properties에 설정을 추가하면 데이터소스와 트랜잭션 매니저를 자동 등록
   - 기본 HikariDataSource, 커넥션 풀 관련 설정도 application.properties에서 가능
   - 트랜잭션 매니저는 라이브러리 보고 판단
6. 언 체크 예외로 변경, 예외 포함/스택 트레이스

### 스프링 예외 추상화
- 데이터베이스 오류에 따라서 특정 예외는 공통처리 하지 않고 복구하고 싶을 수 있다
- 예외 구분할 필요성이 생김 -> SQL ErrorCode 활용
  - 같은 오류여도 db마다 오류 코드 다름
  - ex) H2에서는 키 중복 오류가 23505. MySQL은 1062
- 스프링은 데이터 접근 계층에 대한 수십 가지 예외를 정리해서 일관된 예외 계층을 제공
- 예외의 최고 상위는 org.springframework.dao.DataAccessException, 런타임 예외 상속 받았음
  - 크게 두가지로 구분
  - Transient (일시적), Transient 하위 예외는 동일한 SQL을 다시 시도했을 때 성공할 가능성이 있다
    - 쿼리 타임아웃, 락 관련 오류
  - NonTransient, 같은 SQL을 그대로 반복해서 실행하면 실패
    - SQL 문법 오류, 데이터베이스 제약조건 위배
- 스프링 -> 데이터베이스에서 발생하는 오류 코드를 스프링이 정의한 예외로 자동으로 변환해주는 변환기를 제공 / RepoV4_2
  - 스프링 SQL 예외 변환기는 SQL ErrorCode를 sql-error-codes.xml 파일에 대입해서 예외 찾아냄
  - 대부분 관계형 데이터베이스 지원
- JdbcTemplate 은 JDBC로 개발할 때 발생하는 반복을 대부분 해결 / RepoV5
  -  트랜 잭션을 위한 커넥션 동기화, 리소스 관리, 예외 변환

### 최종 구조 핵심
- 서비스 계층 순수성
  - 트랜잭션 추상화 + AOP
  - 예외 추상화, 변환기
  - 레포 인터페이스에 의존, DI
- 리포지토리에서 JDBC를 사용하는 반복 코드가 JdbcTemplate 으로 대부분 제거