### JdbcTemplate
- NamedParameterJdbcTemplate 권장
- createStatement:
  "SQL 문장에 값을 문자열로 붙이는 방식" → 사용자가 이상한 값을 넣으면 SQL 구조 자체가 바뀔 수 있음 → SQL 인젝션 위험 큼
- preparedStatement:
"SQL 틀(?)을 미리 만들고 값은 따로 넣는 방식" → 값은 구조에 영향을 못 주고 그냥 데이터로만 처리 → SQL 인젝션 방어 가능
- 동적 쿼리
  - 실행할 때(=요청 받을 때) 조건이나 정렬 같은 SQL 일부가 달라지는 쿼리 
  - 검색 조건이 있을 때만 WHERE 절을 붙이는 경우 
- 왜 필요함?
  - 사용자가 선택할 수 있는 조건이 많으면, 
  - 모든 경우의 쿼리를 미리 만들어두면 → 경우의 수가 너무 많아짐 → 관리 불가능 
  - 그래서 실행 시점에 필요한 부분만 붙여서 그때그때 쿼리를 생성함 
- JdbcTemplate에서 어려운 이유 
  - JdbcTemplate는 완성된 SQL 문자열을 그대로 써야 해서, 
  - 동적 쿼리를 만들려면 문자열을 직접 이어붙여야 함 → 코드가 복잡해짐

### Test
- 데이터베이스 분리
  - 로컬 서버와 테스트가 같은 DB를 쓰면 데이터 오염 발생 → 테스트 전용 DB 분리
  - 테스트는 src/test의 application.properties가 우선 적용
- @Transactional 
  - 테스트 클래스/메서드에 @Transactional만 붙이면, 스프링이 테스트 시작 시 트랜잭션 시작, 종료 시 자동 롤백
  - 테스트에서 시작된 트랜잭션에 서비스/리포지토리 계층도 전파되어 같은 트랜잭션/커넥션 사용
  - @Commit 또는 @Rollback(false) 사용 시 테스트 종료 강제 커밋
- 테스트 - 임베디드 모드 DB(직접 설정)
  - 테스트만을 위해 별도 DB 설치/운영 번거로움 → H2 임베디드(메모리) 모드 사용
  - JVM 내 메모리에서 DB 동작, 앱 종료 시 DB 소멸, 데이터도 함께 사라짐
  - 스프링 부트 -> 데이터소스 설정이 없을 때 임베디드 DB를 자동 구성

### MyBatis
- MyBatis는 XML 기반 SQL 및 강력한 동적 SQL로 복잡한 쿼리 작성이 쉬움. 
- MyBatis 스프링 연동 모듈 @Mapper 스캔, 동적 프록시로 구현체 자동 생성. 
- properties설정으로 (패키지경로, snake → camel 변환) 매핑 편의성 향상.
- 동적 SQL 태그(if, choose, trim, foreach) 숙지 시 생산성↑.
- 태그(sql) 사용시 sql코드 조각 재사용 가능.
- 간단: 애노테이션 SQL 가능(권장은 안함), 대부분 XML 사용 
- #{} 문법은 ?를 넣고 파라미터를 바인딩하는 PreparedStatement 를 사용
- 문자 그대로를 처리하고 싶은 경우 ${} 를 사용 ->  SQL 인젝션 취약

### Jpa
- @contoller -> mvc에서 사용하는 컨트롤러야 알려줌
- @service -> 컴포넌트 등록 외 아무 기능 없음 
- @Repository-> 예외 변환 AOP의 적용 대상
  - 스프링과 JPA를 함께 사용하는 경우 스프링은 JPA 예외 변환기( PersistenceExceptionTranslator )를 등록
  - JPA 관련 예외 -> 스프링 데이터 접근 예외로 변환, 서비스 계층에 jpa 예외 의존성 없애준다

### Spring Data Jpa
- JPA 사용을 더 편리하게 해주는 라이브러리. 반복 CRUD 코드 제거, 쿼리 메서드 자동 생성 등 생산성 극대화
- 공통 인터페이스
  - 구현체는 프록시로 자동 생성되어 스프링 빈으로 등록되므로 별도 구현 클래스 불필요
- 쿼리 메서드
  - 메서드 이름을 분석해 JPQL 자동 생성
- JPQL 직접 작성(@Query)
  쿼리 메서드 한계
- 조건이 많아지면 메서드명이 과도하게 길어짐 
- 조인 등 복잡 조건 표현 어려움 → @Query 또는 다른 도구 권장 
- 동적 쿼리는 약함 → 실무는 Querydsl 권장. Example 기능도 있으나 실무 활용도 낮음
- 스프링 데이터 JPA가 만들어주는 프록시에서 이미 예외 변환을 처리, @Repository 와 관계없이 예외 변환

### Querydsl
- Querydsl와 IntelliJ/Gradle 설정은 버전 업에 따라 조금씩 달라질 수 있음 
- 환경에 따라 동작 이슈가 있을 수 있으므로 “querydsl gradle” 등으로 환경 맞춤 대안을 검색 권장 
- Q타입은 컴파일 시 자동 생성되므로 VCS에 포함하지 않는 것이 좋다
- 동적 쿼리 -> 컴파일 시점에 오류 발견 가능
- 메서드 추출로 재사용 가능

### 구조 선택
- 어댑터 패턴 vs 단순 구조
  - 구조의 안정성(추상화/DI/OCP) vs 단순한 구조와 개발 편의성
- 실용적인 구조
  - CRUD와 단순 조회/복잡한 쿼리 레포지토리 나누기
  - 스프링 데이터 JPA/Querydsl

#### 다양한 데이터 접근 기술 조합 가이드
- 선택 기준 
- 팀 역량, 비즈니스 요구 복잡도에 따라 결정. 정답은 하나가 아님
  - JdbcTemplate/MyBatis: SQL 직접 작성 필요하지만 단순하고 적응 쉬움
  - JPA/스프링 데이터 JPA/Querydsl: 생산성 높지만 학습 곡선 높음. 매우 복잡한 통계 쿼리엔 부적합할 수 있음
- 일반적
  - 기본: JPA + 스프링 데이터 JPA + Querydsl로 90~95% 해결. 
  - 나머지 5~10% 복잡 SQL은 JdbcTemplate/MyBatis로 보완. 
  - 프로젝트 성격에 따라 비율은 변동(복잡 통계가 많으면 JDBC/MyBatis 비중↑).
- 트랜잭션 매니저 선택
  - JPA 계열(JPA, 스프링 데이터 JPA, Querydsl) : JpaTransactionManager
  - SQLMapper (JdbcTemplate, MyBatis) : DataSourceTransactionManager
  - JpaTransactionManager 는 놀랍게도 DataSourceTransactionManager 가 제공하는 기능도 대부분 제공
  - 따라서 JpaTransactionManager 하나만 등록해도 JPA/JdbcTemplate/MyBatis를 단일 트랜잭션으로 묶고 롤백 가능
- 주의점: JPA 플러시 타이밍 
  - JPA 변경은 기본적으로 트랜잭션 커밋 시점에 DB 반영. 
  - 하나의 트랜잭션 안에서 JPA를 통해 데이터를 변경한 다음에 JdbcTemplate을 호출하는 경우 JdbcTemplate에서는 JPA가 변경한 데이터를 읽지 못하는 문제가 발생
  - 해결: JPA 작업 뒤에 flush를 호출해 변경 사항을 DB에 반영한 후 작업 해준다

### 스프링 트랜잭션

#### 선언적 트랜잭션과 AOP
- PlatformTransactionManager 를 사용하는 방법
  - 선언적 트랜잭션 관리 vs 프로그래밍 방식 트랜잭션 관리
  - @Transactional 을 통한 선언적 트랜잭션 관리 방식을 사용하게 되면 기본적으로 프록시 방식의 AOP가 적용
  - @Transactional 애노테이션이 특정 클래스나 메서드에 하나라도 있으면 트랜잭션 AOP는 프록시를 만들어서 스프링 컨테이너에 빈으로 등록
  - 프록시는 내부에 실제 객체 를 참조
- 구체적인 레벨에 적용된 애노테이션이 더 높은 우선순위를 가진다
  - 인터페이스에 @Transactional 사용하는 것은 권장X

#### 트랜잭션 AOP 주의사항 - 프록시 내부 호출
- 내부 호출은 프록시를 거치지 않는다. 따라서 트랜잭션을 적용할 수 없다.
  - target 인스턴스에 있는 internal() 을 직접 호출하게 된 것
  - target 인스턴스에는 트랜잭션을 위한 로직이 없다. 프록시 인스턴스를 통해서 호출 되어야 함
- 내부 호출 문제를 해결하기 위해 가장 실용적인 방법은 클래스를 나눠서 외부 호출로 만들어 주는 것


#### 트랜잭션 AOP 주의사항 - private 메서드에는 트랜잭션 적용 X
- 스프링의 트랜잭션 AOP 기능은 private 메서드에는 트랜잭션이 적용되지 않도록 설정되어 있다.
- public, protected , default 는 외부에서 호출이 가능하다. 
- 트랜잭션은 주로 비즈니스 로직의 시작점에 걸기 때문에 대부분 외부에 열어준 곳을 시작점으로 사용
- 따라서 private 메서드에서는 트랜잭션을 적용이 안된다. 클래스 레벨에 @Transactional이 있어도 적용되지 않으며, 메서드 레벨에 적용하려고 하면 컴파일 오류
- 과거 스프링 부트 버전(스프링 부트 3.0 이전)에서는 protected , default 의 경우에서도 @Transactional이 적용이 안되었으며, 해당 접근제어자를 가진 메서드 레벨에 @Transactional이 붙어있어도 컴파일 오류가 나지 않아서 많은 주의가 요구 된다.

#### 트랜잭션 AOP 주의 사항 - 초기화 시점 (@PostConstruct와 함께 사용시 의도대로 작동하지 않는다)
- @PostConstruct는 해당 빈 자체만 생성되었다고 가정하고 호출된다. 
  - 이는 해당 빈에 관련된 AOP등을 포함한, 전체 스프링 애플리케이션 컨텍스트가 초기화 된 것을 의미하지는 않는다. 
  - 트랜잭션을 처리하는 AOP등은 스프링의 후 처리기(post processer)가 완전히 동작을 끝내서, 스프링 애플리케이션 컨텍스트의 초기화가 완료되어야 적용된다.
- 스프링 빈의 라이프사이클
  - 스프링 컨테이너 생성 
  - 스프링 빈 생성 
  - 의존관계 주입 
  - 빈 처리기 (BeanPostProcessor) - 전처리, postProcessBeforeInitialization()
    - @PostConstruct보다 먼저 호출되지만, 이 메서드 안에서 @PostConstruct 실행 전 준비 작업을 할 수 있음.
  - 초기화 콜백 (@PostConstruct)
    - 빈이 완전히 생성되고 의존성 주입이 완료된 후, 초기화 메서드가 호출.
  - 빈 처리기 (BeanPostProcessor) - 후처리, postProcessAfterInitialization()
    - 초기화가 끝난 후 다시 BeanPostProcessor가 동작하여 프록시 객체 생성 등의 후처리가 진행.
    - 이 과정에서 AOP 프록시가 생성. 
  - 빈 등록 완료 
  - 모든 후처리 작업이 끝난 후, 빈이 스프링 컨테이너에 등록. 
  - 스프링 애플리케이션 컨텍스트 초기화 완료 및 어플리케이션 실행
  - 사용 
  - 소멸 전 콜백 (@PreDestroy, DisposableBean의 destroy)
    - 애플리케이션이 종료되기 전에 빈의 소멸 콜백 메서드가 호출.
  - 스프링 종료 
  - 스프링 컨테이너가 종료되고, 모든 빈이 소멸

#### 트랜잭션 옵션
- value, transactionManager
  - 기본으로 등록된 트랜잭션 매니저를 사용하기 때문에 대부분 생략한다.
  - 사용하는 트랜잭션 매니저가 둘 이상이라면 다음과 같이 트랜잭션 매니저의 이름을 지정해서 구분
- rollbackFor (기본 설정)
  - 체크 예외 -> 기본 커밋, 설정으로 롤백 시킬 수 있음, 비즈니스 의미가 있을 때 사용 
    - 지정시 체크 예외인 Exception 이 발생해도 커밋 대신 롤백, 해당 예외의 자식도 포함
  - 런타임 예외 -> 롤백, 복구 불가능한 예외
  - 활용 (OrderService)
    - 기본 : payStatus 를 완료 상태로 처리하고 정상 처리된다. 
    - 예외 : RuntimeException("시스템 예외") 런타임 예외가 발생한다. 
    - 잔고부족 :
      - payStatus 를 대기 상태로 처리한다.
      - NotEnoughMoneyException("잔고가 부족합니다") 체크 예외가 발생한다. 
      - 잔고 부족은 payStatus 를 대기 상태로 두고, 체크 예외가 발생하지만, order 데이터는 커밋되기를 기대
- propagation
  - 트랜잭션 전파에 대한 옵션
- isolation 
  - 트랜잭션 격리 수준을 지정.
  - 기본 값은 데이터베이스에서 설정한 트랜잭션 격리 수준을 사용하는 DEFAULT
  - 애플리케이션 개발자가 트랜잭션 격리 수준을 직접 지정하는 경우는 드물다
- readOnly
  - 읽기 전용 트랜잭션으로 다양한 성능 최적화 가능
  - 프레임워크 
    - JdbcTemplate은 읽기 전용 트랜잭션 안에서 변경 기능을 실행하면 예외를 던진다. 
    - JPA(하이버네이트)는 읽기 전용 트랜잭션의 경우 커밋 시점에 플러시X, 스냅샷 객체X
  - JDBC 드라이버 
    - 참고로 여기서 설명하는 내용들은 DB와 드라이버 버전에 따라서 다르게 동작하기 때문에 사전에 확인이 필요 
    - 읽기 전용 트랜잭션에서 변경 쿼리가 발생하면 예외를 던진다. 
    - 읽기, 쓰기(마스터, 슬레이브) 데이터베이스를 구분해서 요청.
    - 읽기 전용 트랜잭션의 경우 읽기(슬레이브) 데이터베이스의 커넥션을 획득해서 사용한다.
  - 데이터베이스
    - 데이터베이스에 따라 읽기 전용 트랜잭션의 경우 읽기만 하면 되므로, 내부에서 성능 최적화가 발생

### 트랜잭션 전파
- 목적: 트랜잭션이 이미 진행중일 때, 새로운 트랜잭션 요청이 들어오면 어떻게 동작할지를 결정. 
- 기본 전파 옵션: REQUIRED 
  - 기존 트랜잭션이 없으면 새로 시작 
  - 기존 트랜잭션이 있으면 해당 트랜잭션에 참여
    - 참여한다 -> 해당 트랜잭션을 그대로 따른다는 뜻이고, 동시에 같은 동기화 커넥션을 사용한다는 뜻
- 스프링은 논리 트랜잭션과 물리 트랜잭션 개념을 도입 
  - 물리 트랜잭션 : DB의 실제 트랜잭션 (setAutoCommit(false), commit/rollback)
  - 논리 트랜잭션 : 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위
- 여러 트랜잭션이 함께 사용되는 경우, 처음 트랜잭션을 시작한 외부 트랜잭션이 실제 물리 트랜잭션을 관리
  - 외부 트랜잭션과 내부 트랜잭션이 논리적, 물리적으로 둘다 동일한 커넥션을 사용
- 논리 트랜잭션이 하나라도 롤백되면 물리 트랜잭션은 롤백
  - 외부 논리 트랜잭션 롤백 -> 실제 물리 롤백
  - 내부 논리 트랜잭션이 롤백되면 롤백 전용 마크를 표시 
    - 외부 트랜잭션을 커밋할 때 롤백 전용 마크를 확인
    - 롤백 전용 마크가 표시되어 있으면 물리 트랜잭션을 롤백, UnexpectedRollbackException 예외를 던진다.
    - 내부 트랜잭션이 롤백 되었는데 외부 트랜잭션을 커밋 시키는 상황은 개발자의 입장에서는 의도치 않은 상황일 확률이 매우 크다
      - 따라서 예외로 관리 되는 것
- 다양한 트랜잭션 전파 옵션
  - REQUIRES_NEW
    - 기존 트랜잭션 없음: 새로운 트랜잭션을 생성
    - 기존 트랜잭션 있음: 새로운 트랜잭션을 생성
  - 나머지 거의 쓸 일 없음
  - 트랜잭션 옵션
    - isolation , timeout , readOnly 는 트랜잭션이 처음 시작될 때만 적용된다. 트랜잭션에 참여하는 경우에는 적용되지 않는다