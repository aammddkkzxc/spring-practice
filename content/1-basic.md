#### 스프링 원리
- ioc
    - 기존
        - 프로그램의 각 객체(클라이언트 구현 객체)가 자신이 사용할 다른 객체(서버 구현 객체)를 직접 생성하고, 연결하며, 실행하는 등 프로그램의 제어 흐름을 스스로 관리
    - ioc 방식
        - AppConfig와 같은 외부 설정 파일 또는 컨테이너가 등장, 객체는 자신의 핵심 로직을 실행하는 역할만 맡는다.
        - 객체 생성, 의존관계 설정 등 프로그램의 제어 흐름 전체를 외부(AppConfig)에서 관리. 객체는 어떤 구현체가 자신과 연결되어 실행될지 알지 못함.
- di
    - 정적인 클래스 의존 관계
        - 코드 작성 시점에 결정되는 의존 관계
    - 동적인 객체(인스턴스) 의존 관계
        - 프로그램이 실행되는 시점에 실제 어떤 구현 객체가 연결될지에 대한 관계.
        - 어떤 구현체가 실제로 연결되어 동작할지는 실행 시점에 결정.
        - DI는 이 동적인 객체 의존 관계를 외부(컨테이너)에서 주입해주는 것을 의미

#### 스프링 컨테이너와 빈
- 스프링 컨테이너를 부를 때 BeanFactory와 ApplicationContext로 구분할 수 있으며, 이 둘은 상속 관계에 있다
- BeanFactory : 스프링 빈을 관리하고 조회하는 역할. 사용할일 거의 없음
- ApplicationContext : BeanFactory 기능을 모두 상속받아서 제공, 부가기능 포함. 대부분의 경우에 사용
- BeanDefinition : 스프링이 다양한 형태의 설정 정보를 BeanDefinition으로 추상화해서 사용

#### 싱글톤 패턴과 싱글톤 컨테이너
- 싱글톤 패턴 문제점
    - 클라이언트가 구체클래스에 의존(dip, ocp위반), 테스트 어려움(애플리케이션에서 공유됨), 내부 상태 변경 어렵다
- 싱글톤 컨테이너
    - 스프링 컨테이너는 싱글톤 패턴 없이 기본적으로 빈(Bean)을 싱글톤으로 관리, 싱글톤 컨테이너라고 불린다
- 싱글톤 방식 주의점 -> 무상태로 설계 해야 한다.
- `@Configuration` : 바이트코드를 조작하는 CGLIB 기술을 사용해서 싱글톤을 보장

#### 의존관계 주입, 빈 자동/수동 등록
- 주입할 스프링 빈이 없을 경우 동작하려면 -> `@Autowired`의 required=false / `@Nullable` / Optional<>
- 생성자 주입이 선택되는 이유
    - 대부분 의존관계 주입은 변경할 일이 없다
    - 컴파일 시점에 누락된 의존 관계 알아낼 수 있다 (final키워드)
- 주입 빈 충돌 (조회 대상 빈이 2개 이상)
    - @Autowired 는 타입 매칭을 시도하고, 이때 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름
    - @Qualifier 사용
    - @Primary 사용 (@Qualifier 보다 우선순위 낮음)
- 의도적으로 정말 해당 타입의 스프링 빈이 다 필요한 경우도 있다
    - List, Map사용
    - 이런 경우 별도의 설정 정보 클래스를 만들고, 사용 빈들을 수동 등록 하여 한눈에 보기 슆도록 하자
  ```
  @Configuration
  public class DiscountPolicyConfig {

  @Bean
  public DiscountPolicy rateDiscountPolicy() {
  return new RateDiscountPolicy();
  }
  
  @Bean
  public DiscountPolicy fixDiscountPolicy() {
  return new FixDiscountPolicy();
  }
  }
  ```
- 내가 직접 정의/등록하는, 애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체(데이터베이스 연결, 공통 로그 처리 처리, AOP)는 수동 빈으로 등록해서 설정 정보 클래스에서 한눈에 볼 수 있도록 하는 것이 유지보수에 좋다

#### 빈 생명주기 콜백
- 스프링 빈의 이벤트 라이프사이클
- 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료
- `@PostConstruct`, `@PreDestroy` 애노테이션 사용. 외부 라이브러리의 경우 `@Bean 옵션 사용`

#### 빈 스코프
- 싱글톤 : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
- 프로토타입 : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프
- 웹 관련 스코프
- 싱글톤과 프로토타입 빈의 동시 사용 : 생명주기의 불일치
    - 문제는 싱글톤 빈이 프로토타입 빈을 의존할 때 발생.
        - 최초 주입 시점 : 싱글톤 빈이 생성되면서 프로토타입 빈의 새로운 인스턴스가 단 한 번 생성되어 주입.
        - 이후 사용 시점 : 싱글톤 빈은 자신의 생명주기 동안 처음에 주입받았던 동일한 프로토타입 빈 인스턴스를 계속 사용. 결과적으로 프로토타입 빈을 사용하는 목적(매번 새로운 객체 사용)을 달성할 수 없게 된다.
    - 해결 방안: 의존성 조회(Dependency Lookup) 활용
        - 전통적인 의존성 주입(DI) 방식 대신, 빈을 사용하는 시점에서 매번 새로운 인스턴스를 컨테이너에 요청하는 의존성 조회(DL) 방식을 사용
        - 빈 자체를 주입받는 것이 아니라, 프로토타입 빈을 생성할 수 있는 '제공자'를 주입
        - ObjectProvider 사용 (스프링 표준), JSR-330 Provider 사용 (자바 표준)
        - 스프링 외에 다른 컨테이너를 쓸 일이 아니라면 스프링 표준 사용하자, 만약 필요하다면 gralde의존관계 추가하고 자바 표준
- 웹 스코프 -> provider 사용하거나 `@Scope`의 proxyMode 사용
    - 진짜 객체 조회를 꼭 필요한 시점까지 지연처리
    - 웹 스코프가 아니어도 프록시는 사용할 수 있다